<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jerin&#39;s Blog</title>
    <description>这里是 @Jerin 的个人博客，与你一起发现更大的世界。</description>
    <link>http://jerinw.github.io/</link>
    <atom:link href="http://jerinw.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 20 Jun 2016 23:15:43 +0800</pubDate>
    <lastBuildDate>Mon, 20 Jun 2016 23:15:43 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>小心思</title>
        <description>&lt;p&gt;可怕，居然因为去不去可莎蜜儿又惹我汤生气了……谁说女票生气的时候一个熊抱就没事了的，妈的越抱我汤越生气……&lt;/p&gt;

&lt;p&gt;憋了好久发了一句晚安，但我汤又不理我了……&lt;/p&gt;

&lt;p&gt;十一点了…….估计今晚不会理我了……&lt;/p&gt;

&lt;p&gt;别拦我，我要去练立即消失这个技能了，这样我汤就不会不开心了。&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Jun 2016 05:28:00 +0800</pubDate>
        <link>http://jerinw.github.io/2016/06/20/About-Tang/</link>
        <guid isPermaLink="true">http://jerinw.github.io/2016/06/20/About-Tang/</guid>
        
        <category>Tang</category>
        
        
      </item>
    
      <item>
        <title>与汤筱晴的这些天</title>
        <description>&lt;p&gt;今天你好像有点不开心，删了微博，屏蔽了朋友圈。我有点摸不着头脑，不知道是我惹的，还是考试惹的，或者其他。总之看你不开心，我就挺难过的。&lt;/p&gt;

&lt;p&gt;下午想聊一些好玩的事让你多说说话，可是好像又惹你生气了，感觉自己蠢die……&lt;/p&gt;

&lt;p&gt;送你回家以后就站在你家楼下思考了一下哪里做得不好，下次遇到这种情况该怎么办。想着想着你麻麻就下楼扔垃圾了，吓我一跳，急忙上前叫一声阿姨好。&lt;/p&gt;

&lt;p&gt;估计麻麻是以为我们吵架你不想理我，把我关在门外，就托一个邻居扔了垃圾，然后自己偷笑着跑上去了，好萌哈哈。&lt;/p&gt;

&lt;p&gt;我知道你我都是要有自己的空间的，以后我还是先做好自己的事，少缠着你，不过陪你回家已经成了我一个不大不小的习惯，还是想跟你多呆一会的。&lt;/p&gt;

&lt;p&gt;总之呢我汤最好天天开心啦，生活总有烦闷，你想一个人的时候我尽量不打扰你，想吐槽的时候我也可以做你的树洞，嘻嘻爱你。&lt;/p&gt;
</description>
        <pubDate>Sun, 19 Jun 2016 07:49:00 +0800</pubDate>
        <link>http://jerinw.github.io/2016/06/19/About-Tang/</link>
        <guid isPermaLink="true">http://jerinw.github.io/2016/06/19/About-Tang/</guid>
        
        <category>Tang</category>
        
        
      </item>
    
      <item>
        <title>Blog on my own</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;如今我的小屋已经砌成，在此分享一下经验，正文中部分内容参考了网上其他教程。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#build&quot;&gt;跳过废话&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说起来也是今年刚开始写的博客，打算记录一下自己最近做的事，或是记录学习工作上遇到的问题，如何解决的。开始选择了新浪博客，但用着用着发现了很多不喜欢的地方，比如布局背景不能随意更换，文章字体行距不能选择，代码不能高亮……作为一个工科生怎么能被这些束缚住手脚呢，那么就自己动手搭一个自己的博客吧，想怎么改就怎么改，想着反正实验室有好多世界各地的服务器，搞个域名也不难。一开始查资料有人推荐Wordpress，后来又了解了Jekyll,Hexo,最后确定用Jeckyll。&lt;/p&gt;

&lt;p&gt;为什么选择用Jekyll，我是这么觉得的：&lt;/p&gt;

&lt;p&gt;首先不是每个人都想去花钱买空间买域名的，Jekyll生成的网页可以托管在Github上。其次Jekyll简洁明了，Wordpress功能如此强大，以至于大家都是在不断折腾Wordpress本身，而不是专注于写博客。然后Jekyll技术门槛相对较低，Markdown写起来也比较顺手。其实它也有一定缺点，比如Jekyll生成的都是静态网页，如果要加评论的模块比较麻烦，其次它是不依托数据库的，也就是说每次运行都要遍历所有文本文件，要是网站做得越大，生成时间也就越长。但是瑕不掩瑜，而且Jekyll是Proudly hosted by Github的（微笑）总结来说，用Jekyll就是：免费，简洁，够用。&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;本博客使用&lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot;&gt;Markdown&lt;/a&gt; + &lt;a href=&quot;http://jekyll.bootcss.com/&quot;&gt;Jekyll&lt;/a&gt; + &lt;a href=&quot;https://pages.GitHub.com/&quot;&gt;GitHub Pages&lt;/a&gt; 的技术方案搭建。&lt;/p&gt;

&lt;p&gt;其中 Jekyll 是一个博客形态的静态站点产生器，能够将.Markdown转换成可以发布的完整网站。使用 Jekyll 来进行本地网站的调试然后用Git进行 Blog 的发布。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; 是Github推出的展示自我和项目的网站。你的网站直接托管在自己的 GitHub 仓库上，默认使用GitHub的子域名，通过 Git 命令管理，不用自己捣腾主机，也没有流量和空间限制.是一个非常理想的展示的空间。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;本地准备&lt;/h3&gt;

&lt;p&gt;接下来要介绍本地的准备，系统为Win7，文本编辑器用的Sublime text。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.安装 &lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;Ruby&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意64位和32位的区别，我装的是 Ruby 2.2.4(x64)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意安装时一定要勾选添加到环境变量！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-06-15/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.安装 &lt;a href=&quot;https://rubygems.org/pages/download&quot;&gt;RubyGems&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Windows下使用zip格式较为方便，将下载的文件解压到任意路径下。打开Windows的命令行窗口
(Win8以后可以按win+x+a)，输入命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd {你的解压地址}
$ ruby setpu.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.安装 Jekyll&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在命令行输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem install jekyll
$ gem install jekyll-paginate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.配置 Git 环境&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先安装 &lt;a href=&quot;https://git-for-windows.GitHub.io/&quot;&gt;git for windows&lt;/a&gt;
我装的是Git-2.9.0-64-bit。全部默认即可,完成以后，后续配置需要用到GitHub账号，在后文中介绍。&lt;/p&gt;

&lt;h3 id=&quot;github&quot;&gt;GitHub准备&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1.创建自己的 &lt;a href=&quot;https://GitHub.com/&quot;&gt;GitHub&lt;/a&gt; 账号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.设置 git 账号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在本地打开安装好的 Git Bash。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160326173741565&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt;中执行以下命令，设置你的 git 用户名和邮箱：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git config --global user.name &quot;{username}&quot;          // 用你的用户名替换{username}
$ git config --global user.email &quot;{name@site.com}&quot;    // 用你的邮箱替换{name@site.com}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.配置SSH&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了和GitHub的远程仓库进行传输，需要配置SSH。在&lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt;中执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh-keygen -t rsa -C&quot;{name@site.com}&quot;    // 用你的邮箱替换{name@site.com}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样在&lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\username&lt;/code&gt;下会生成一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.ssh&lt;/code&gt;文件夹。我的路径是在C:\Program Files\Java\jdk1.8.0_51.ssh，反正在命令行下有提示，如下图。
&lt;img src=&quot;/img/2016-06-15/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来使用浏览器登录你的GitHub账户，点击右上角的”Settings”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-06-15/3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击“SSH and GPG Keys”，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-06-15/4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用文本编辑器打开&lt;code class=&quot;highlighter-rouge&quot;&gt;.ssh&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;id_rsa.pub&lt;/code&gt;文件，将内容复制粘贴到Key中，
点“Add SSH Key”确定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160326173829850&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;配置好SSH之后，便可以在本地使用 git 访问自己的 GitHub 远程仓库了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.创建自己的 GitHub Pages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GitHub 自动将命名规则为&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;yourusername&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.github.io&lt;/span&gt;&lt;/code&gt;的仓库识别为 GitHub Pages 项目。简单的
建站方法是挑选一个自己喜欢的&lt;a href=&quot;https://github.com/jekyll/jekyll/wiki/sites&quot;&gt;模板&lt;/a&gt;, 将其Fork到
自己的空间。例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160326173933085&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后在你的主页点开之前Fork的仓库，点击”Settings”,将“Repository name”改为
 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;yourusername&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.github.io&lt;/span&gt;&lt;/code&gt;，点击“Rename”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160326173955662&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成之后便可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;http://{yourusername}.github.io&lt;/code&gt;来访问你Fork的网站啦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.同步仓库&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了方便网站的调试和 Blog 的编辑，我们需要将托管在 GitHub 上的仓库同步到本地计算机上。
再次打开Git Bash，输入以下命令切换到你想放置本地代码仓库的位置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd {本地路径}     // 比如：cd e:/workspace
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;clone（克隆）你自己的 GitHub Pages 远程仓库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/{username}/{username}.github.io.git     
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160326174041711&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时所有远程仓库里的源码都拷贝到 &lt;code class=&quot;highlighter-rouge&quot;&gt;e:/workspace/{username}.github.io&lt;/code&gt; 这个文件夹里来了。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;正式使用&lt;/h3&gt;

&lt;p&gt;有了前面的准备，现在就可以正式的编辑网站和写 Blog 啦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.Jekyll简单使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在终端中输入命令:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd {local repository} // {local repository}替换成你的本地仓库的目录
$ jekyll serve
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果一切顺利，通过浏览器访问 http://localhost:4000/ 就已经可以看到自己的网站啦。&lt;/p&gt;

&lt;p&gt;注意&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll serve
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll serve -watch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;功能相似，开启服务后都可以查看网站效果，也能检测到修改。个人感觉差别在于被动刷新和主动
检测上。而Jekyll配置文件_config.yml的改动则需要重启服务才能生效。&lt;/p&gt;

&lt;p&gt;所有的 Blog 放在仓库的 &lt;code class=&quot;highlighter-rouge&quot;&gt;_POST&lt;/code&gt; 文件夹下，命名遵循 &lt;code class=&quot;highlighter-rouge&quot;&gt;y-m-d-title.format&lt;/code&gt; 的格式。&lt;/p&gt;

&lt;p&gt;对 Jekyll &lt;a href=&quot;http://jekyll.bootcss.com/docs/usage/&quot;&gt;基本用法&lt;/a&gt;和
&lt;a href=&quot;http://jekyll.bootcss.com/docs/usage/&quot;&gt;目录结构&lt;/a&gt;的更多介绍，需要的时候可以自己查看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.使用 Git 更新 Blog&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;无论是修改网站还是更新 Blog ，都可以通过 Git 命令来完成。打开 Git Bash 切换地址到本地仓库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd {your repository}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果之前使用 Git 与其他远程仓库建立过连接，则需要断开旧的连接连接到我们的 GitHub Pages 仓库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote rm origin
$ git remote add origin https://github.com/{yourusername}/{yourusername}.github.io.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在 Bash 中输入一下命令将本地修改同步到GitHub上:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add .
$ git commit -m &quot;statement&quot;   //此处statement填写此次提交修改的内容，作为日后查阅
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;完成后就能在你的主页上看到更新了。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;接下来打算要做的有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;多写一些博客，不只是技术的，还有日常；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加一个评论系统；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完善 Blog 的翻页支持；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加搜索功能；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加转发功能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 15 Jun 2016 22:00:00 +0800</pubDate>
        <link>http://jerinw.github.io/2016/06/15/Blog-on-my-own/</link>
        <guid isPermaLink="true">http://jerinw.github.io/2016/06/15/Blog-on-my-own/</guid>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>Android Camera</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;最近在做安卓程序开发，一个车牌识别的项目，其实车牌识别已经挺成熟了，只是：&lt;/p&gt;

&lt;p&gt;1.安卓平台的识别比较少&lt;/p&gt;

&lt;p&gt;2.对中文的支持不太好​​​&lt;/p&gt;

&lt;p&gt;​之前试过两个开源的识别项目，一个是国外的Openalpr，看起来做得很好的样子，适用的平台也很多，虽然从字符上看还是支持中文的，但是实际检测的时候从来测不出中文。一个是国内的easypr，号称有95%的识别率，试了一下发现识别率应该没有这么高，但是还可以吧，起码支持中文，是cpp写的。&lt;/p&gt;

&lt;p&gt;于是就打算​把easypr移植到安卓上，Github上有现成版本可以参考，但是只能识别本地一张固定名称的照片，特别傻，于是就打算调用一下摄像头，直接手机上点一下识别了。&lt;/p&gt;

&lt;p&gt;核心的识别部分还是用的CPP的源码​​，NDK的配置什么就不讲了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;​### A.权限&lt;/p&gt;

&lt;p&gt;首先在manifest.xml里加入摄像头权限和读写SD卡权限&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&amp;gt;
    &amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&amp;gt;
    &amp;lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;b&quot;&gt;B.加入控件&lt;/h3&gt;

&lt;p&gt;layout的xml文件里加surfaceview，摄像头捕获的内容就显示在这个控件里。fill_parent表示控件有多大内容就有多大，比如这个activity里没有别的控件了，那这个摄像头捕获的图像就满屏幕，跟照相机一样，如果有别的控件，就填满除这个控件外剩下的空间。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&amp;lt;SurfaceView
	    android:id=&quot;@+id/surfaceview&quot;
	    android:layout_width=&quot;fill_parent&quot;
	    android:layout_height=&quot;fill_parent&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-06-13/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;c&quot;&gt;C.懒得写了，贴源码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.example.carplate;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;

import org.opencv.android.BaseLoaderCallback;
import org.opencv.android.LoaderCallbackInterface;
import org.opencv.android.OpenCVLoader;
import org.opencv.core.Mat;
import org.opencv.highgui.Highgui;

import android.os.Bundle;
import android.os.Environment;
import android.app.Activity;
import android.content.Context;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.hardware.Camera;
import android.hardware.Camera.PictureCallback;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.widget.ImageView;
import android.widget.TextView;

public class MainActivity extends Activity implements SurfaceHolder.Callback, Camera.PictureCallback {
	private ImageView imageView = null;
	private Bitmap bmp = null;
	private TextView m_text = null;
	private String path = null;
	
	private static Context context = null;  
	private SurfaceView surfaceview;  
	private SurfaceHolder surfaceholder;  
	private Camera camera = null;
	private boolean af;
	
	static {
	    if (!OpenCVLoader.initDebug()) {
	    } else {
	        System.loadLibrary(&quot;imageproc&quot;);
	    }
	}
	

//	protected void onCreate(Bundle savedInstanceState) {
//		super.onCreate(savedInstanceState);
//		setContentView(R.layout.activity_main);
//		imageView = (ImageView) findViewById(R.id.image_view);
//		m_text = (TextView) findViewById(R.id.myshow);
//		bmp = BitmapFactory.decodeResource(getResources(), R.drawable.plate_locate);
//		imageView.setImageBitmap(bmp);
//		path = Environment.getExternalStorageDirectory().getAbsolutePath(); 
//	}
	@Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        context = this;  
        
        m_text = (TextView) findViewById(R.id.myshow);  
        surfaceview = (SurfaceView)findViewById(R.id.surfaceview);  
        surfaceholder = surfaceview.getHolder();  
        surfaceholder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);  
        surfaceholder.addCallback(MainActivity.this);  //这里的safeactivity改成了mainactivity
        path = Environment.getExternalStorageDirectory().getAbsolutePath();
        //path新加，为了后来拍完照片存到识别的目录
        
    }  

	private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {
		@Override
		public void onManagerConnected(int status) {
			switch (status) {
			case LoaderCallbackInterface.SUCCESS: {
			}
				break;
			default: {
				super.onManagerConnected(status);
			}
				break;
			}
		}
	};
	
/**
 *识别的模块，点下那个识别的button以后要根据这两个训练好的svm.xml和ann.xml识别这张plate_locate.jpg。其中path为SD卡根目录
 */
	public void click(View view) throws UnsupportedEncodingException {
		System.out.println(&quot;entering the jni&quot;);
		String svmpath = path+&quot;/svm.xml&quot;;
		String annpath = path+&quot;/ann.xml&quot;;
		String imgpath = path+&quot;/plate_locate.jpg&quot;;
		byte[] resultByte = CarPlateDetection.ImageProc(imgpath,svmpath,annpath);
		String result = new String(resultByte,&quot;GBK&quot;);
		System.out.println(result);
		m_text.setText(result);
	}

	@Override
	protected void onResume() {
		super.onResume();
		mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);
	}
	
/**
 *摄像头捕获图像预览的模块  
 */
	@Override  
	public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {  
	    System.out.println(&quot;surfacechanged&quot;);  
	}  
	@Override  
	public void surfaceCreated(SurfaceHolder holder) {  
	    System.out.println(&quot;surfacecreated&quot;);  
	    //获取camera对象  
	    camera = Camera.open();  
	    try {  
	        //设置预览监听  
	        camera.setPreviewDisplay(holder);  
	        Camera.Parameters parameters = camera.getParameters();  
	          
	        if (this.getResources().getConfiguration().orientation   
	                    != Configuration.ORIENTATION_LANDSCAPE) {  
	            parameters.set(&quot;orientation&quot;, &quot;portrait&quot;);  
	            camera.setDisplayOrientation(90);  
	            parameters.setRotation(90);  
	        } else {  
	            parameters.set(&quot;orientation&quot;, &quot;landscape&quot;);  
	            camera.setDisplayOrientation(0);  
	            parameters.setRotation(0);  
	        }  
	        camera.setParameters(parameters);  
	        //启动摄像头预览  
	        camera.startPreview();  
	        System.out.println(&quot;camera.startpreview&quot;);  
	          
	    } catch (IOException e) {  
	        e.printStackTrace();  
	        camera.release();  
	        System.out.println(&quot;camera.release&quot;);  
	    }  
	}  
	@Override  
	public void surfaceDestroyed(SurfaceHolder arg0) {  
	    System.out.println(&quot;surfaceDestroyed&quot;);  
	    if (camera != null) {  
	        camera.stopPreview();  
	        camera.release();
	        camera =null;
	    }  
	}  
	
/**
 * 拍照的模块，点击屏幕自动对焦，松开手指时拍照，并保存在SD卡根目录
 */
    @Override
    public boolean onTouchEvent(MotionEvent event) {//屏幕触摸事件
    	if (event.getAction() == MotionEvent.ACTION_DOWN) {//按下时自动对焦
            camera.autoFocus(null);
            af =true;
        }
        if (event.getAction() == MotionEvent.ACTION_UP &amp;amp; af ==true) {//放开后拍照
            camera.takePicture(null, null,this);
            af =false;
        }
        return true;
    }
 
    public void onPictureTaken(byte[] data, Camera camera) {//拍摄完成后保存照片
    	try {
            String picpath = path +&quot;/plate_locate.jpg&quot;;
            data2file(data, picpath);
        } catch (Exception e) {
        }
        camera.startPreview();
    }
 
    private void data2file(byte[] w, String fileName) throws Exception {//将二进制数据转换为文件的函数
        FileOutputStream out =null;
        try {
            out =new FileOutputStream(fileName);
            out.write(w);
            out.close();
        } catch (Exception e) {
            if (out !=null)
                out.close();
            throw e;
        }
    }
 

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;其实就是在一个车牌识别的软件里加一个摄像头的功能，使其可以直接拍照识别，其中CarPlateDetection.ImageProc这个函数写在另外的文件里，是调用一些cpp文件实现的。&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 23:02:00 +0800</pubDate>
        <link>http://jerinw.github.io/2016/06/13/Android-camera/</link>
        <guid isPermaLink="true">http://jerinw.github.io/2016/06/13/Android-camera/</guid>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>Brief Introduction to Sitewhere</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;IOT(Internet OfThings)也就是我们常说的物联网，实际上就是用互联网实现各种设备间的通信，使得这些物品组成一个或大或小的网络。其目的是实现设备的统筹管理以更好地服务于人类，实现我们各种需求。可以认为是互联网的对象从人到物的一个转换。&lt;/p&gt;

&lt;p&gt;而sitewhere则是一个开源的物联网平台，它帮我们搭起了一个系统以方便我们实现数据的读取储存，程序的运行。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;物联网服务器平台​&lt;/h2&gt;

&lt;p&gt;1.作为类似一个处理设备数据的控制器的应用。服务器可以装在本地机器上，也可以跑在云端，每天可以处理炒鸡炒鸡多的事件。&lt;/p&gt;

&lt;p&gt;2.可以储存设备的数据，过往的设备事件数据也是不删的​，再多事件也不删。比如管理倒闸的话，A车进，A车出，B车进，这种历史记录都是永远存在的。&lt;/p&gt;

&lt;p&gt;3.提供给服务供应商接口，允许第三方定制扩展。这里的服务供应商就是指给客户提供服务的人，也就是我们这些写软件的。&lt;/p&gt;

&lt;p&gt;4.可以轻松地注册新设备，并且实现设备和sitewhere之间的接受发送数据​。系统还有一系列接口可以让你自己增加沟通协议，编码计划和配置设定。&lt;/p&gt;

&lt;p&gt;5.提供了一个HTML5 ​管理应用，使得系统的数据可以一种更好理解的方式来查看和操作。管理的app和第三方app都可以通过REST接口与sitewhere进行交互。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;设备管理​&lt;/h2&gt;

&lt;p&gt;1.提供了一套完整的设备管理模型。&lt;/p&gt;

&lt;p&gt;2.提供了设备数据的规范模型。&lt;/p&gt;

&lt;p&gt;3.把设备和外部事物或者人联系起来​，比如一个校徽，就跟戴校徽的我联系起来，这样方便追踪事件。A车就跟A车车牌联系起来，发现这个车牌，就知道这辆车进去或者出去了。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;集成&lt;/h2&gt;

&lt;p&gt;1.集成了第三方的工作框架，如​ MuleAnyPoint，Salesforce，Twilio。&lt;/p&gt;

&lt;p&gt;2.用java的话，几行代码就能利用REST[注1]服务实现与sitewhere的交互。​&lt;/p&gt;

&lt;p&gt;3.通过balabala建立的信息保护机制​。&lt;/p&gt;

&lt;p&gt;[注1]​REST(Representational StateTransfer)即表述性状态传递，描述了一个架构样式的网络系统，比如web 应用程序。可以把它理解为一种软件架构风格，而符合这个风格的程序就是RESTful。&lt;/p&gt;

&lt;p&gt;即，REST是一个框架，这个框架的实现就是RESTful。​&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;文章都是老博客搬过来的。本来打算一边学习Sitewhere，一边更新，就当学习笔记的。后来手头事情比较多，Sitewhere端做得比较少，也不怎么看了。&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Mar 2016 18:42:00 +0800</pubDate>
        <link>http://jerinw.github.io/2016/03/28/sitewhere/</link>
        <guid isPermaLink="true">http://jerinw.github.io/2016/03/28/sitewhere/</guid>
        
        <category>技术</category>
        
        
      </item>
    
  </channel>
</rss>
